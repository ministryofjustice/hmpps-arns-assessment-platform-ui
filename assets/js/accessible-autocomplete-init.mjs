/**
 * Accessible Autocomplete Initializer
 *
 * Automatically initializes accessible-autocomplete on all elements
 * with the data-module="accessible-autocomplete" attribute.
 *
 * Expected HTML structure (generated by AccessibleAutocomplete form-engine component):
 *
 * <script type="application/json" id="autocomplete-data-fieldCode">
 *   ["Option 1", "Option 2"] or { "key1": ["..."], "key2": ["..."] }
 * </script>
 * <div class="accessible-autocomplete-wrapper"
 *      data-module="accessible-autocomplete"
 *      data-autocomplete-source="autocomplete-data-fieldCode"
 *      data-autocomplete-source-key-from="#other-input"
 *      data-autocomplete-min-length="2"
 *      data-autocomplete-show-no-options="false"
 *      data-autocomplete-menu-classes="custom-class">
 *   <input type="text" id="fieldCode" name="fieldCode" ...>
 * </div>
 *
 * @see https://github.com/alphagov/accessible-autocomplete
 */

import accessibleAutocomplete from 'accessible-autocomplete'

/**
 * Get autocomplete data from the JSON script tag.
 *
 * @param {string} sourceId - ID of the script tag containing JSON data
 * @returns {object} Parsed JSON data or empty object
 */
function getAutocompleteData(sourceId) {
  const dataElement = document.getElementById(sourceId)

  if (!dataElement) {
    console.warn(`Accessible autocomplete: data element #${sourceId} not found`)
    return {}
  }

  try {
    return JSON.parse(dataElement.textContent || '{}')
  } catch (e) {
    console.error(`Accessible autocomplete: failed to parse JSON from #${sourceId}`, e)
    return {}
  }
}

/**
 * Get the source array for the autocomplete.
 * Handles both flat arrays and keyed objects.
 *
 * @param {HTMLElement} wrapper - The wrapper element with data attributes
 * @returns {string[]} Array of autocomplete options
 */
function getSource(wrapper) {
  const sourceId = wrapper.dataset.autocompleteSource

  if (!sourceId) {
    return []
  }

  const data = getAutocompleteData(sourceId)

  // If we have a key selector, look up the nested data
  const keyFromSelector = wrapper.dataset.autocompleteSourceKeyFrom

  if (keyFromSelector && typeof data === 'object' && !Array.isArray(data)) {
    const keyElement = document.querySelector(keyFromSelector)
    const key = keyElement?.value ?? ''
    return data[key] ?? []
  }

  // Otherwise, assume flat array
  return Array.isArray(data) ? data : []
}

/**
 * Initialize a single autocomplete wrapper.
 *
 * @param {HTMLElement} wrapper - The wrapper element to initialize
 */
function initializeAutocomplete(wrapper) {
  const input = wrapper.querySelector('input')

  if (!input) {
    console.warn('Accessible autocomplete: no input found in wrapper', wrapper)
    return
  }

  const source = getSource(wrapper)
  const defaultValue = input.value
  const inputId = input.id
  const inputName = input.name

  // Update the associated label to point to the new autocomplete input
  const label = document.querySelector(`label[for="${inputId}"]`)

  if (label) {
    label.setAttribute('for', `${inputId}-autocomplete`)
  }

  // Remove the original input - accessibleAutocomplete will create its own
  input.remove()

  // Parse options from data attributes
  const minLength = parseInt(wrapper.dataset.autocompleteMinLength ?? '2', 10)
  const showNoOptionsFound = wrapper.dataset.autocompleteShowNoOptions === 'true'
  const menuClasses = wrapper.dataset.autocompleteMenuClasses ?? null
  const inputClasses = wrapper.dataset.autocompleteInputClasses ?? null
  const hintClasses = wrapper.dataset.autocompleteHintClasses ?? null
  const autoselect = wrapper.dataset.autocompleteAutoselect === 'true'
  const confirmOnBlur = wrapper.dataset.autocompleteConfirmOnBlur !== 'false' // default true
  const displayMenu = wrapper.dataset.autocompleteDisplayMenu ?? 'inline'
  const showAllValues = wrapper.dataset.autocompleteShowAllValues === 'true'
  const menuAttributes = wrapper.dataset.autocompleteMenuAttributes
    ? JSON.parse(wrapper.dataset.autocompleteMenuAttributes)
    : {}

  // Initialize the autocomplete
  accessibleAutocomplete({
    element: wrapper,
    id: `${inputId}-autocomplete`,
    name: inputName,
    source,
    defaultValue,
    minLength,
    showNoOptionsFound,
    menuClasses,
    inputClasses,
    hintClasses,
    autoselect,
    confirmOnBlur,
    displayMenu,
    showAllValues,
    menuAttributes,
  })
}

/**
 * Initialize all accessible autocomplete components on the page.
 */
export function initAccessibleAutocompletes() {
  const wrappers = document.querySelectorAll('.accessible-autocomplete-wrapper[data-module="accessible-autocomplete"]')

  wrappers.forEach(wrapper => {
    initializeAutocomplete(wrapper)
  })
}

/**
 * Auto-initialize on DOMContentLoaded if this module is loaded directly.
 */
if (typeof document !== 'undefined') {
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAccessibleAutocompletes)
  } else {
    // DOM already loaded, initialize immediately
    initAccessibleAutocompletes()
  }
}
